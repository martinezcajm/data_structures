<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TAD_Stack: adt_stack_ops_s Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TAD_Stack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structadt__stack__ops__s-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">adt_stack_ops_s Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad3a6a6641cf29b37d37eabe475edb80d"><td class="memItemLeft" align="right" valign="top">s16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#ad3a6a6641cf29b37d37eabe475edb80d">destroy</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> **stack)</td></tr>
<tr class="memdesc:ad3a6a6641cf29b37d37eabe475edb80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the stack.  <a href="#ad3a6a6641cf29b37d37eabe475edb80d">More...</a><br /></td></tr>
<tr class="separator:ad3a6a6641cf29b37d37eabe475edb80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c226930bfa114fdd0daaf41959fab"><td class="memItemLeft" align="right" valign="top">s16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#a947c226930bfa114fdd0daaf41959fab">reset</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:a947c226930bfa114fdd0daaf41959fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the stack.  <a href="#a947c226930bfa114fdd0daaf41959fab">More...</a><br /></td></tr>
<tr class="separator:a947c226930bfa114fdd0daaf41959fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7b66eb29da8fb49b3626354a30d3a4"><td class="memItemLeft" align="right" valign="top">s16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#a8b7b66eb29da8fb49b3626354a30d3a4">resize</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack, u16 new_size)</td></tr>
<tr class="memdesc:a8b7b66eb29da8fb49b3626354a30d3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the capacity of the stack.  <a href="#a8b7b66eb29da8fb49b3626354a30d3a4">More...</a><br /></td></tr>
<tr class="separator:a8b7b66eb29da8fb49b3626354a30d3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16d5aec35876e8824938765a9001461"><td class="memItemLeft" align="right" valign="top">u16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#af16d5aec35876e8824938765a9001461">capacity</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:af16d5aec35876e8824938765a9001461"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of capacity  <a href="#af16d5aec35876e8824938765a9001461">More...</a><br /></td></tr>
<tr class="separator:af16d5aec35876e8824938765a9001461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77aa49422bbfe038dd3f9eb93e14882"><td class="memItemLeft" align="right" valign="top">u16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#ae77aa49422bbfe038dd3f9eb93e14882">length</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:ae77aa49422bbfe038dd3f9eb93e14882"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the length  <a href="#ae77aa49422bbfe038dd3f9eb93e14882">More...</a><br /></td></tr>
<tr class="separator:ae77aa49422bbfe038dd3f9eb93e14882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3315785cb5d870e9cc4eb9c0b1efc79"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#ac3315785cb5d870e9cc4eb9c0b1efc79">isEmpty</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:ac3315785cb5d870e9cc4eb9c0b1efc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the stack is empty.  <a href="#ac3315785cb5d870e9cc4eb9c0b1efc79">More...</a><br /></td></tr>
<tr class="separator:ac3315785cb5d870e9cc4eb9c0b1efc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af792db2d70632a11b1ae12af63eb020b"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#af792db2d70632a11b1ae12af63eb020b">isFull</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:af792db2d70632a11b1ae12af63eb020b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the stack is full.  <a href="#af792db2d70632a11b1ae12af63eb020b">More...</a><br /></td></tr>
<tr class="separator:af792db2d70632a11b1ae12af63eb020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b7d3b5744eb99bf08fa0b14f155b3"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#ad28b7d3b5744eb99bf08fa0b14f155b3">first</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:ad28b7d3b5744eb99bf08fa0b14f155b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first element of the stack.  <a href="#ad28b7d3b5744eb99bf08fa0b14f155b3">More...</a><br /></td></tr>
<tr class="separator:ad28b7d3b5744eb99bf08fa0b14f155b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338622d8e3c8f09ecf73d80cb0f59466"><td class="memItemLeft" align="right" valign="top">s16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#a338622d8e3c8f09ecf73d80cb0f59466">push</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack, void *data, u16 data_size)</td></tr>
<tr class="memdesc:a338622d8e3c8f09ecf73d80cb0f59466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the data at the first position of the stack.  <a href="#a338622d8e3c8f09ecf73d80cb0f59466">More...</a><br /></td></tr>
<tr class="separator:a338622d8e3c8f09ecf73d80cb0f59466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86683f4cd4288e5ed0eeea63f1e70b34"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#a86683f4cd4288e5ed0eeea63f1e70b34">pop</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:a86683f4cd4288e5ed0eeea63f1e70b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the first element of the stack and returns it.  <a href="#a86683f4cd4288e5ed0eeea63f1e70b34">More...</a><br /></td></tr>
<tr class="separator:a86683f4cd4288e5ed0eeea63f1e70b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a720f9a9df992759870c3d71a92c29"><td class="memItemLeft" align="right" valign="top">s16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#a98a720f9a9df992759870c3d71a92c29">concat</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack, <a class="el" href="structadt__stack__s.html">Stack</a> *src)</td></tr>
<tr class="memdesc:a98a720f9a9df992759870c3d71a92c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two stack storing the result at origin.  <a href="#a98a720f9a9df992759870c3d71a92c29">More...</a><br /></td></tr>
<tr class="separator:a98a720f9a9df992759870c3d71a92c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87496a132c816759887ab1e3989f77be"><td class="memItemLeft" align="right" valign="top">u16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#a87496a132c816759887ab1e3989f77be">traverse</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack, void(*callback)(<a class="el" href="structmemory__node__s.html">MemoryNode</a> *))</td></tr>
<tr class="memdesc:a87496a132c816759887ab1e3989f77be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the callback method to the stack.  <a href="#a87496a132c816759887ab1e3989f77be">More...</a><br /></td></tr>
<tr class="separator:a87496a132c816759887ab1e3989f77be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bd0c94f3d8638a8ffaba45936372c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadt__stack__ops__s.html#af91bd0c94f3d8638a8ffaba45936372c">print</a> )(<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td></tr>
<tr class="memdesc:af91bd0c94f3d8638a8ffaba45936372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the content of the elements of the stack.  <a href="#af91bd0c94f3d8638a8ffaba45936372c">More...</a><br /></td></tr>
<tr class="separator:af91bd0c94f3d8638a8ffaba45936372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af16d5aec35876e8824938765a9001461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16d5aec35876e8824938765a9001461">&#9670;&nbsp;</a></span>capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16(* adt_stack_ops_s::capacity) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter of capacity </p>
<p>Returns the maximum number of elemets that can be stored at the stack.</p>
<dl class="section return"><dt>Returns</dt><dd>u16 capacity of the stack </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack we wish to get the capacity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98a720f9a9df992759870c3d71a92c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a720f9a9df992759870c3d71a92c29">&#9670;&nbsp;</a></span>concat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16(* adt_stack_ops_s::concat) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack, <a class="el" href="structadt__stack__s.html">Stack</a> *src)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two stack storing the result at origin. </p>
<p>Concatenates the source to the stack, in case one of the stack has infinite capacity the result stack will have infinite capacity, otherwise it will be the result of both capacities added. Notice that the src stack won't be modified during the execution. In case the stack is null kErrorCode_Null_Queue will be returned and in case the the src is null kErrorCode_Null_Pointer_Parameter_Received. If there's a problem during the allocation of the new stack kErrorCode_Error_Trying_To_Allocate_Memory will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>s16 status of the operation once finished </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack that will store the result of the concatenation </td></tr>
    <tr><td class="paramname">*src</td><td>stack we want to concatenate to our origin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a6a6641cf29b37d37eabe475edb80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a6a6641cf29b37d37eabe475edb80d">&#9670;&nbsp;</a></span>destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16(* adt_stack_ops_s::destroy) (<a class="el" href="structadt__stack__s.html">Stack</a> **stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the stack. </p>
<p>Initializes the stack, this method must only be called from Create as it will assume the pointer passed to it is a valid one created by the Create functionality.</p>
<dl class="section return"><dt>Returns</dt><dd>s16 ErrorCode of the execution </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack we wish to initialize </td></tr>
    <tr><td class="paramname">capacity</td><td>number of elements that the stack can store note that a value of 0 will imply that it has an infinite capacityDestroys the stack and it's data</td></tr>
  </table>
  </dd>
</dl>
<p>Destroys the stack and its data. Note that this function calls the reset method. In case the direction to the pointer is null it will return a kErrorCode_Null_Pointer_Reference_Received. If the execution went well this function assures that the pointer to stack ends as NULL</p>
<dl class="section return"><dt>Returns</dt><dd>s16 ErrorCode of the execution </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">**stack</td><td>direction to the pointer of the stack we want to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad28b7d3b5744eb99bf08fa0b14f155b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28b7d3b5744eb99bf08fa0b14f155b3">&#9670;&nbsp;</a></span>first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* adt_stack_ops_s::first) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first element of the stack. </p>
<p>TODO change descriptionReturns a reference to the first node. If the stack passed is NULL or the stack is empty returns null.</p>
<dl class="section return"><dt>Returns</dt><dd>void* first element of the stack </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3315785cb5d870e9cc4eb9c0b1efc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3315785cb5d870e9cc4eb9c0b1efc79">&#9670;&nbsp;</a></span>isEmpty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* adt_stack_ops_s::isEmpty) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if the stack is empty. </p>
<p>Indicates if the stack is empty</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the stack is empty false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af792db2d70632a11b1ae12af63eb020b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af792db2d70632a11b1ae12af63eb020b">&#9670;&nbsp;</a></span>isFull</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* adt_stack_ops_s::isFull) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if the stack is full. </p>
<p>Indicates if the stack is full</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the stack is full false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae77aa49422bbfe038dd3f9eb93e14882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77aa49422bbfe038dd3f9eb93e14882">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16(* adt_stack_ops_s::length) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter of the length </p>
<p>Returns the current number of elements (&lt;= capacity)</p>
<dl class="section return"><dt>Returns</dt><dd>u16 length of the stack </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack we wish to get the length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86683f4cd4288e5ed0eeea63f1e70b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86683f4cd4288e5ed0eeea63f1e70b34">&#9670;&nbsp;</a></span>pop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* adt_stack_ops_s::pop) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the first element of the stack and returns it. </p>
<p>TODO change description Extracts the first element of the stack and removes it. Notice that the data must be freed once you are finished using it as it's no longer responsability of the stack.</p>
<dl class="section return"><dt>Returns</dt><dd>void* data at the first position of the stack </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af91bd0c94f3d8638a8ffaba45936372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91bd0c94f3d8638a8ffaba45936372c">&#9670;&nbsp;</a></span>print</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* adt_stack_ops_s::print) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the content of the elements of the stack. </p>
<p>Prints the content of the elements of the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a338622d8e3c8f09ecf73d80cb0f59466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338622d8e3c8f09ecf73d80cb0f59466">&#9670;&nbsp;</a></span>push</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16(* adt_stack_ops_s::push) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack, void *data, u16 data_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the data at the first position of the stack. </p>
<p>TODO change description Inserts the data at the first position of the stack and returns the status depending of the result. In case the stack is full a kErrorCode_Queue_Is_Full is returned, if the stack is null kErrorCode_Null_Queue and in case the the data is null kErrorCode_Null_Data. The stack makes a copy of the data so the value you store will not be touched unless you modify it through the stack.</p>
<dl class="section return"><dt>Returns</dt><dd>s16 status of the operation once finished </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack </td></tr>
    <tr><td class="paramname">*data</td><td>data we wish to store at the position </td></tr>
    <tr><td class="paramname">data_size</td><td>size of the data we wish to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a947c226930bfa114fdd0daaf41959fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c226930bfa114fdd0daaf41959fab">&#9670;&nbsp;</a></span>reset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16(* adt_stack_ops_s::reset) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the stack. </p>
<p>Frees the elements of the stack, using the reset method of memory node, and sets the values of the stack to it's default. In case a null pointer was passed it will return a kErrorCode_Null_Queue</p>
<dl class="section return"><dt>Returns</dt><dd>s16 ErrorCode of the execution </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack we wish to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7b66eb29da8fb49b3626354a30d3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7b66eb29da8fb49b3626354a30d3a4">&#9670;&nbsp;</a></span>resize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16(* adt_stack_ops_s::resize) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack, u16 new_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the capacity of the stack. </p>
<p>Adjusts the capacity of the stack so it can store more elements. If the new size causes a loss of data the function will return an error. Note that a capacity of 0 is an infinite capacity</p>
<dl class="section return"><dt>Returns</dt><dd>s16 ErrorCode of the execution </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack we wish to resuze </td></tr>
    <tr><td class="paramname">new_size</td><td>new size for the stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87496a132c816759887ab1e3989f77be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87496a132c816759887ab1e3989f77be">&#9670;&nbsp;</a></span>traverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16(* adt_stack_ops_s::traverse) (<a class="el" href="structadt__stack__s.html">Stack</a> *stack, void(*callback)(<a class="el" href="structmemory__node__s.html">MemoryNode</a> *))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the callback method to the stack. </p>
<p>Applies a memory node function to the set of elements of the stack.</p>
<dl class="section return"><dt>Returns</dt><dd>u16 number of elements traveled </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*stack</td><td>pointer to the stack </td></tr>
    <tr><td class="paramname">*callback</td><td>function of memory node that will be applied to the set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/ESAT/2ab_ma_martinezcajm/2semestre/stack/include/<a class="el" href="adt__stack_8h_source.html">adt_stack.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
